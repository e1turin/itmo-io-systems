# Лабораторная №1. Вариант 8.

## Задание

### Цель работы

> Получить знания и навыки разработки драйверов символьных устройств для
> операционной системы Linux.

### Задачи

1. Написать драйвер символьного устройства, удовлетворяющий требованиям:
    1. Драйвер должен создавать символьное устройство /dev/varN, где N – это
       номер варианта.
    2. Должен обрабатывать операции записи и чтения в соответствии с вариантом
       задания (варианты представлены ниже).
2. Для подготовки отчета выполнить:
    1. Склонировать на github.com структуру репозитория:
       https://gitlab.se.ifmo.ru/io-systems/report-skeleton
    2. Выложить исходные файлы и скрипты для сборки драйвера в папку lab1
       репозитория
    3. Написать отчет о проделанной работе в файл lab1/README.md репозитория по
       предложенному шаблону, размещенному в файле.

### Текст варианта 8

> При записи в файл символьного устройства текста, содержащего цифры, должен
> запоминаться результат умножения всех чисел, разделенных другими символами
> (буквы, пробелы и т.п.). Последовательность полученных результатов с момента
> загрузки модуля ядра должна выводиться при чтении файла

## Полезные материалы

- J. Corbet, A. Rubini, G. Kroah-Hartman. Linux Device Drivers. Third Edition.
  2005. P. 638
- Общая информация о ядре Linux (eng):
  https://developer.ibm.com/technologies/linux/articles/l-linux-kernel
- Информация по разработке драйверов устройств
  http://ruslinux.net/MyLDP/BOOKS/drivers/linux-device-drivers-00.html
- Информация по сборке внешнего модуля ядра (eng):
  https://www.kernel.org/doc/html/latest/kbuild/modules.html
- О символьных устройствах (eng):
  https://linux-kernellabs.github.io/refs/heads/master/labs/device_drivers.html

- - -

# Комментарии

Где-то нужно хранить данные. Это может быть кольцевой буфер, но когда место
заканчивается, нужно дать обратную связь, например, вывести сообщение в
кольцевой буффер ядра.

- "можно посмотреть как работает ввод/вывод в файлы в Linux"
- https://sysprog21.github.io/lkmpg/ — наиболее информативный
  материал с примерами. есть перевод на habr:
- https://habr.com/ru/companies/ruvds/articles/681880/
- http://crossplatform.ru/?q=node/340
- https://habr.com/ru/companies/timeweb/articles/680850/
- https://habr.com/ru/articles/343828/


Еще нужно понять, что значат параметры в функциях fops:
- https://unix.stackexchange.com/questions/680598/when-you-define-a-read-function-for-a-kernel-module-where-does-the-functions-a
- https://fastbitlab.com/linux-device-driver-programming-lecture-39-understanding-read-method/

В текущей реализации размер буфера ограничен 4, чтобы можно было наглядно видеть, как происходит переполнение.
Так почти каждое действие драйвера логируется в кольцевой буфер ядра, что не
является необходимым, так что можно добавить макрос для отключения всех
логирований в *prod* сборке.

